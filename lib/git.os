		
Функция ПолучитьНазваниеТекущейВетки(КаталогРепозитария) Экспорт

	ПроцессГит = Создатьпроцесс("git rev-parse --abbrev-ref HEAD"
								,КаталогРепозитария
								,Истина
								,Ложь
								,КодировкаТекста.UTF8);
	ПроцессГит.Запустить();										
	ПроцессГит.ОжидатьЗавершения();
	
	НазваниеТекущейВетки  = СокрЛП(ПроцессГит.ПотокВывода.Прочитать());

	Возврат НазваниеТекущейВетки;

КонецФункции

Функция ПолучитьНазваниеВеткиСлияния() Экспорт

	ПроцессГит = Создатьпроцесс("git cherry -v HEAD MERGE_HEAD"
								,ТекущийКаталог()
								,Истина
								,Ложь
								,КодировкаТекста.UTF8);
	ПроцессГит.Запустить();										
	ПроцессГит.ОжидатьЗавершения();

	ТекстСообщения  = ПроцессГит.ПотокВывода.Прочитать();

	Возврат СокрЛП(ТекстСообщения);
	//Возврат "origin1c";
	
КонецФункции

Функция НайтиПутьРодительскогоОбъекта(ТекущийПуть, Журнал)

	Журнал.Отладка("Ищу родителя для: " + ТекущийПуть);

	МасСтр = СтрРазделить(ТекущийПуть, "\");
	
	ФайлСуществует = Ложь;

	Пока Не ФайлСуществует Цикл
		
		МасСтр.Удалить(МасСтр.Количество() - 1);
	
		ПутьРодитель = СтрСоединить(МасСтр, "\") + ".xml";
		ПутьРодитель = СтрЗаменить(ПутьРодитель, "Config.xml", "Config\Configuration.xml");

		Файл = Новый Файл(ПутьРодитель);

		Журнал.Отладка("Пробую: " + ПутьРодитель);

		Если Файл.Существует() И Не СтрНайти(ПутьРодитель, "Form.xml") И Не СтрНайти(ПутьРодитель, "Forms")  Тогда
			
			ФайлСуществует = истина;
			Журнал.Отладка("Файл существует: " + ПутьРодитель);

		КонецЕсли;

	КонецЦикла;	
	
	Возврат ПутьРодитель;

КонецФункции

Функция ОбработатьФайлИзменений(ПутьКРепозитарию, ИмяФайлаСпискаФайлов, Журнал) Экспорт
	
	ПутьКВременномуКаталогу = ОбъединитьПути(КаталогВременныхФайлов(), "1C_GIT_PART");
	СоздатьКаталог(ПутьКВременномуКаталогу);
	УдалитьФайлы(ПутьКВременномуКаталогу, "*.*");
	
	ИмяВрФайла = ПолучитьИмяВременногоФайла();

	// Добавить путь к репозитарию
	ЧТ = Новый ЧтениеТекста(ИмяФайлаСпискаФайлов, КодировкаТекста.UTF8);
	ЗТ = Новый ЗаписьТекста(ИмяВрФайла, КодировкаТекста.UTF8);
	
	Стр = ЧТ.ПрочитатьСтроку();
	СтрЗТ = "";

	ТЗ = Новый ТаблицаЗначений;
	ТЗ.Колонки.Добавить("Новый");
	ТЗ.Колонки.Добавить("Путь");
	ТЗ.Колонки.Добавить("Уровень");

	Пока не Стр = неопределено Цикл
		
		Журнал.Отладка("Обрабатываю " + Стр);

		Стр = СтрРазделить(Стр, Символы.Таб);
		
		Если Не СокрЛП(Стр) = "" И НЕ Лев(Стр[0], 1) = "R" Тогда

			СтрЗТ = "" + ПутьКРепозитарию + "\" + СтрЗаменить(Стр[1],"/","\");
			
		ИначеЕсли Лев(Стр[0], 1) = "R" Тогда
			
			СтрЗТ = "" + ПутьКРепозитарию + "\" + СтрЗаменить(Стр[2],"/","\");

		Иначе

			СтрЗТ = "";
		
		КонецЕсли;

		ЭтоНовыйОбъект = Ложь;

		Если Стр[0] = "A" Тогда	//или Лев(Стр[0], 1) = "R" 
			
			ЭтоНовыйОбъект = Истина;

		КонецЕсли;	


		Если Стр[0] = "R088" ИЛИ СтрНайти(Стр[1], "Config/") = 0 ИЛИ СтрНайти(Стр[1], "Config/ConfigDumpInfo.xml") <> 0 Тогда
		
			Журнал.Информация("Пропускаю  " + Стр[0] + "	" + Стр[1]);
			Стр = ЧТ.ПрочитатьСтроку();
			Продолжить;
		
		КонецЕсли;
		
		БылоПреобразование = Ложь;
		
		ПозExt = СтрНайти(СтрЗТ, "\Ext\");
		Если ПозExt > 0 И 
		
		НЕ (СтрНайти(СтрЗТ, "Config\Ext\") > 0 ИЛИ СтрНайти(СтрЗТ, "ObjectModule") > 0 ИЛИ СтрНайти(СтрЗТ, "ManagerModule") > 0 ИЛИ СтрНайти(СтрЗТ, "CommandModule") > 0) // Эти модули загружаются частично из папки \Ext объектов

		Тогда
		
			Если СтрНайти(СтрЗТ, "Forms") > 0 И СтрНайти(СтрЗТ, "Module.bsl") > 0 Тогда //Модули форм совершенно точно не загружаются (возможно это ошибка платформы), необходимо загружать объект формы
				
				ПозМодуля = СтрНайти(СтрЗТ, "Module.bsl");
				ИмяФормы = Сред(СтрЗТ, ПозExt + 5, ПозМодуля - ПозExt - 6);
				СтрЗТ = Сред(СтрЗТ, 1, ПозExt + 4) + ИмяФормы  + ".xml";
				БылоПреобразование = Истина;
		
			Иначе
			
				СтрЗТ = Сред(СтрЗТ, 1, ПозExt - 1) + ".xml";
				БылоПреобразование = Истина;
				
			КонецЕсли;
			
		КонецЕсли;		
		
		Если СтрНайти(СтрЗТ, "Config.xml") > 0 Тогда
		
			СтрЗТ = ОбъединитьПути(ПутьКРепозитарию, "Config\Configuration.xml");
		
		КонецЕсли;			
		
		Если БылоПреобразование Тогда
		
			Журнал.Информация("Преобразовано: " + ПутьКРепозитарию + "\" + СтрЗаменить(Стр[1],"/","\") + " -> " + СтрЗТ);
			
		КонецЕсли;

		Если СтрНайти(СтрЗТ, "\Config") > 0 И Не СокрЛП(СтрЗТ) = "" Тогда
		
			Если (Стр[0] = "A" или Стр[0] = "D") и СтрЗаканчиваетсяНа(СтрЗТ, "xml") Тогда
		
				СтрРодитель = НайтиПутьРодительскогоОбъекта(СтрЗТ, Журнал);

				СтрТз= ТЗ.Добавить();
				СтрТз.Новый = Ложь;
				СтрТз.Путь = СтрРодитель;
				СтрТз.Уровень = СтрЧислоВхождений(СтрРодитель, "\")*-1;
			
				Журнал.Информация(Стр[0] + " " + СтрЗТ + " -> " + СтрРодитель);
			
			КонецЕсли;
		
			Если не Стр[0] = "D" Тогда
			
				СтрТз= ТЗ.Добавить();
				СтрТз.Новый = ЭтоНовыйОбъект;
				СтрТз.Путь = СтрЗТ;
				СтрТз.Уровень = СтрЧислоВхождений(СтрЗТ, "\")*-1;// * ?(ЭтоНовыйОбъект, -1, 1);
			
			КонецЕсли;
		
		КонецЕсли;
		
		Стр = ЧТ.ПрочитатьСтроку();
		
	КонецЦикла; 

	//ТЗ.Сортировать("Путь");
	ТЗ.Сортировать("Уровень, Путь");
	//ТЗ.Свернуть("Путь, Новый");
	ТЗ.Свернуть("Путь");

	// копирование файлов во временный каталог для загрузки в конфигурацию
	Для каждого СтрТз из ТЗ Цикл
		
		ПутьКРезультатуКопирования = СтрЗаменить(СтрТз.Путь, ПутьКРепозитарию, ПутьКВременномуКаталогу);
		Журнал.Информация("Копирую во временный каталог: " + СтрТз.Путь + " в " + ПутьКРезультатуКопирования);
		Файл = Новый Файл(ПутьКРезультатуКопирования);
		СоздатьКаталог(Файл.Путь);
		ИсходныйФайл = Новый Файл(СтрТз.Путь);
		Если ИсходныйФайл.Существует() Тогда
			КопироватьФайл(СтрТз.Путь, ПутьКРезультатуКопирования);
		КонецЕсли;
		
		//Если НЕ СтрТз.Новый Тогда // пропускаем все добавленные ("A") объекты, они будут загружаться при загрузке их родительских объектов
			
			ЗТ.ЗаписатьСтроку(ПутьКРезультатуКопирования);

		//КонецЕсли;	
		
		//Копирование одноименных (объекту) папок в папку загрузки
		ПутьОбъект = ОбъединитьПути(ИсходныйФайл.Путь, ИсходныйФайл.ИмяБезРасширения);
		КаталогОбъект = Новый Файл(ПутьОбъект);
		Если КаталогОбъект.Существует() Тогда
			МасФайлов = НайтиФайлы(ПутьОбъект, "*.*", Истина);
			Для Каждого ФайлОбъект Из МасФайлов Цикл
				Если ФайлОбъект.Существует() И не ФайлОбъект.ЭтоКаталог() Тогда
					ПутьКРезультатуКопирования = СтрЗаменить(ФайлОбъект.ПолноеИмя,ПутьКРепозитарию,ПутьКВременномуКаталогу);
					Файл = Новый Файл(ПутьКРезультатуКопирования);
					СоздатьКаталог(Файл.Путь);
					Журнал.Информация("Копирую во временный каталог: " + ФайлОбъект.ПолноеИмя + " в " + ПутьКРезультатуКопирования);
					КопироватьФайл(ФайлОбъект.ПолноеИмя, ПутьКРезультатуКопирования);
				КонецЕсли;	
			КонецЦикла;
		КонецЕсли;
		
		
		ПутьExt = ?(ИсходныйФайл.ИмяБезРасширения = "Configuration", ОбъединитьПути(ИсходныйФайл.Путь, "Ext"), ОбъединитьПути(ИсходныйФайл.Путь, ИсходныйФайл.ИмяБезРасширения , "Ext"));
		КаталогExt = Новый Файл(ПутьExt);
		Если КаталогExt.Существует() Тогда
			МасФайлов = НайтиФайлы(ПутьExt, "*.*", Истина);
			Для Каждого ФайлExt Из МасФайлов Цикл
				Если ФайлExt.Существует() И не ФайлExt.ЭтоКаталог() Тогда
					ПутьКРезультатуКопирования = СтрЗаменить(ФайлExt.ПолноеИмя,ПутьКРепозитарию,ПутьКВременномуКаталогу);
					Файл = Новый Файл(ПутьКРезультатуКопирования);
					СоздатьКаталог(Файл.Путь);
					Журнал.Информация("Копирую во временный каталог: " + ФайлExt.ПолноеИмя + " в " + ПутьКРезультатуКопирования);
					КопироватьФайл(ФайлExt.ПолноеИмя, ПутьКРезультатуКопирования);
				КонецЕсли;	
			КонецЦикла;
		КонецЕсли;
		
	КонецЦикла;

	ЗТ.Закрыть();
	ЧТ.Закрыть();

	УдалитьФайлы(ИмяФайлаСпискаФайлов);
	ПереместитьФайл(ИмяВрФайла, ИмяФайлаСпискаФайлов);

	//Если ТЗ.Количество() > 0 Тогда
	
	//	Журнал.Информация("Копирую во временный каталог: " + ОбъединитьПути(ПутьКРепозитарию, "Config", "ConfigDumpInfo.xml") + " в " + ОбъединитьПути(ПутьКВременномуКаталогу, "Config", "ConfigDumpInfo.xml"));
	//	КопироватьФайл(ОбъединитьПути(ПутьКРепозитарию, "Config", "ConfigDumpInfo.xml"), ОбъединитьПути(ПутьКВременномуКаталогу, "Config", "ConfigDumpInfo.xml"));
	
	//КонецЕсли;
	
	ПутьКРепозитарию = ПутьКВременномуКаталогу;
	
	Возврат ТЗ.Количество();
	
КонецФункции

Процедура ПерейтиНаВетку(ПутьКРепозитарию, ИмяВетки, Журнал = неопределено) Экспорт

	ТекущаяВетка = ПолучитьНазваниеТекущейВетки(ПутьКРепозитарию);

	// Проверить текущую ветку и если она не соответствует, перейти на нее
	Если Не ТекущаяВетка = ИмяВетки Тогда
	
		ЗапуститьПриложение("git checkout " + ИмяВетки, ПутьКРепозитарию, Истина);
		
	ИначеЕсли Не Журнал = неопределено Тогда
		
		Журнал.Информация("переход на ветку " + ИмяВетки + " так как текущая ветка и так " + ТекущаяВетка);
		
	КонецЕсли;

КонецПроцедуры

Процедура ПолучитьСписокИзмененийВФайл(Знач ПутьКРепозитарию, Знач ИмяФайлаСпискаФайлов, Журнал, СравниваемыеКомиты = Неопределено) Экспорт
	
	Если не СравниваемыеКомиты = Неопределено Тогда
		Сообщить("Запускаю: cmd /C git diff " + СравниваемыеКомиты[0] + " " + СравниваемыеКомиты[1] + " --name-status > " + ИмяФайлаСпискаФайлов);
		ЗапуститьПриложение("cmd /C git diff " + СравниваемыеКомиты[0] + " " + СравниваемыеКомиты[1] + " --name-status > " + ИмяФайлаСпискаФайлов, ПутьКРепозитарию, Истина);
	
	Иначе
		
		ЗапуститьПриложение("cmd /C git diff @{1}.. --name-status > " + ИмяФайлаСпискаФайлов, ПутьКРепозитарию, Истина);
		//ЗапуститьПриложение("cmd /C git diff d1315564988df781c8d8e88245564284cc82e7bf f43dc75005c330be4c8f88b9df87593da94e07eb --name-status > " + ИмяФайлаСпискаФайлов, ПутьКРепозитарию, Истина);
		
	КонецЕсли;	
	
	
КонецПроцедуры
